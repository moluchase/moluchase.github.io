<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft Yahei:300,300italic,400,400italic,700,700italic|Microsoft Yahei:300,300italic,400,400italic,700,700italic|Microsoft Yahei:300,300italic,400,400italic,700,700italic|Microsoft Yahei:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="神经网络和深度学习[1-2]神经网络和深度学习[1-3]神经网络和深度学习[1-4]改善深层神经网络：超参数调试、正则化以及优化【2-1】改善深层神经网络：超参数调试、正则化以及优化【2-2】改善深层神经网络：超参数调试、正则化以及优化【2-3】结构化机器学习项目 3 Ng的深度学习视频笔记，长期更新">
<meta property="og:type" content="article">
<meta property="og:title" content="Basic of Neural Network Programming">
<meta property="og:url" content="http://yoursite.com/2017/12/06/dl02/index.html">
<meta property="og:site_name" content="moluchase">
<meta property="og:description" content="神经网络和深度学习[1-2]神经网络和深度学习[1-3]神经网络和深度学习[1-4]改善深层神经网络：超参数调试、正则化以及优化【2-1】改善深层神经网络：超参数调试、正则化以及优化【2-2】改善深层神经网络：超参数调试、正则化以及优化【2-3】结构化机器学习项目 3 Ng的深度学习视频笔记，长期更新">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/upload/essayimage/dl/dl0201.png">
<meta property="og:image" content="http://yoursite.com/upload/essayimage/dl/dl0202.png">
<meta property="og:image" content="http://yoursite.com/upload/essayimage/dl/dl0203.png">
<meta property="og:image" content="http://yoursite.com/upload/essayimage/dl/dl0204.png">
<meta property="og:image" content="http://yoursite.com/upload/essayimage/dl/dl0205.png">
<meta property="og:image" content="http://yoursite.com/upload/essayimage/dl/dl0206.png">
<meta property="og:image" content="http://yoursite.com/upload/essayimage/dl/dl0207.png">
<meta property="og:image" content="http://yoursite.com/upload/essayimage/dl/dl0208.png">
<meta property="og:updated_time" content="2017-12-20T08:55:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Basic of Neural Network Programming">
<meta name="twitter:description" content="神经网络和深度学习[1-2]神经网络和深度学习[1-3]神经网络和深度学习[1-4]改善深层神经网络：超参数调试、正则化以及优化【2-1】改善深层神经网络：超参数调试、正则化以及优化【2-2】改善深层神经网络：超参数调试、正则化以及优化【2-3】结构化机器学习项目 3 Ng的深度学习视频笔记，长期更新">
<meta name="twitter:image" content="http://yoursite.com/upload/essayimage/dl/dl0201.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/06/dl02/"/>





  <title> Basic of Neural Network Programming | moluchase </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0bfbafc8c8254a80a162ed15e4e48f48";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">moluchase</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">step by step</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/dl02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Peng song">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="moluchase">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Basic of Neural Network Programming
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T20:27:52+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Deep Learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/12/06/dl02/" class="leancloud_visitors" data-flag-title="Basic of Neural Network Programming">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p><a href="https://moluchase.github.io/2017/12/06/dl02/#more" target="_blank" rel="external">神经网络和深度学习[1-2]</a><br><a href="https://moluchase.github.io/2017/12/08/dl03/#more" target="_blank" rel="external">神经网络和深度学习[1-3]</a><br><a href="https://moluchase.github.io/2017/12/10/dl04/#more" target="_blank" rel="external">神经网络和深度学习[1-4]</a><br><a href="https://moluchase.github.io/2017/12/11/dl05/#more" target="_blank" rel="external">改善深层神经网络：超参数调试、正则化以及优化【2-1】</a><br><a href="https://moluchase.github.io/2017/12/12/dl06/#more" target="_blank" rel="external">改善深层神经网络：超参数调试、正则化以及优化【2-2】</a><br><a href="https://moluchase.github.io/2017/12/14/dl07/#more" target="_blank" rel="external">改善深层神经网络：超参数调试、正则化以及优化【2-3】</a><br><a href="https://moluchase.github.io/2017/12/17/dl08/#more" target="_blank" rel="external">结构化机器学习项目 3</a></p>
<p>Ng的深度学习视频笔记，长期更新<br><a id="more"></a></p>
<h4 id="2-3-logistic-Regression-Cost-Function"><a href="#2-3-logistic-Regression-Cost-Function" class="headerlink" title="2.3 logistic Regression: Cost Function"></a>2.3 logistic Regression: Cost Function</h4><p>  二分类问题，每个特征前面有一个权重，然后加上一个偏置项，即<script type="math/tex">y=w^Tx+b</script>，我们想让这个结果要么是0，要么是1，那么就用到了sigmod函数，即<script type="math/tex">\sigma(z)=\frac{1}{1+e^{-z}}</script>，讲义中给出的是对于样本<script type="math/tex">(x^{(i)},y^{(i)})</script>而言，有如下公式：</p>
<script type="math/tex; mode=display">\hat{y}^{(i)}=\sigma(w^Tx^{(i)}+b)=\frac{1}{1+e^{-(w^Tx^{(i)}+b)}}</script><p>该样本的损失函数（loss function）一般为<script type="math/tex">\frac{1}{2}(\hat{y}^{(i)}-y^{(i)})^2</script>，但是在logistic回归中一般使用下面的损失函数：</p>
<script type="math/tex; mode=display">L(\hat{y}^{(i)},y^{(i)})=-\big(y^{(i)}\,log(\hat{y}^{(i)})+(1-y^{(i)})\,log(1-\hat{y}^{(i)})\big)</script><p>原因是因为平方损失函数（误差平方）在讨论最优化问题的时候是非凸的，即会得到多个局部最优解(梯度下降法可能找不到全局最优解)，而用log损失函数，起着和误差平方相似的作用，会给我们一个凸的优化问题，很容易做优化。<br>对于多个样本的成本函数(cost function) J 如下：</p>
<script type="math/tex; mode=display">
J(w,b)=\frac{1}{m}\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})\\
=-\frac{1}{m}\sum_{i=1}^m\big((y^{(i)}log(\hat{y}^{(i)})+(1-y^{(i)})log(1-\hat{y}^{(i)}))\big)</script><p>成本函数是损失函数的平均值，通过改变参数w，b来使成本函数最小<br>【补充】：这节课有几个地方需要补充：为什么log损失是凸的，为什么误差平方使用梯度可能找不到全局最优,损失函数有哪几种，该如何使用<br>log的损失函数标准形式是：<script type="math/tex">L(Y,P(Y|X))=-logP(Y|X)</script>，和上面的对应的<br>先给出logistic回归针对二分类的模型表达式：</p>
<script type="math/tex; mode=display">
f(x)=w*x+b\\
P(Y=1|x)=\frac{e^{f(x)}}{1+e^{f(x)}}\\
P(Y=0|x)=\frac{1}{1+e^{f(x)}}</script><p>这样对应上面的损失函数，就会得到成本函数【注意：损失函数衡量单个样本，成本函数衡量多个样本】：</p>
<script type="math/tex; mode=display">
J=-\big(y\,logP(Y=1|x)+(1-y)\,logP(Y=0|x)\big)</script><p>而log函数是单调递增的，所以logP(Y|X)也是单调递增的，而-logP(Y|X)即为单调递减，这样使用梯度下降就可以找到全局最小值<br>而误差平方函数本身就是二次曲线，虽然是凸的，但是组合成的成本函数就不是凸的了<br>关于损失函数，这里只简单的提一下：<br>给出这么几种损失函数：<br>Among all linear methods <script type="math/tex">y=f(\theta^Tx)</script>, we need to first determine the form of <script type="math/tex">f</script>, and then finding <script type="math/tex">\theta</script>by formulating it to maximizing likelihood or minimizing loss. This is straightforward.</p>
<p>For classification, it’s easy to see that if we classify correctly we have <script type="math/tex">y\cdot f = y\cdot \theta^Tx\gt0</script>, and <script type="math/tex">y\cdot f = y\cdot\theta^Tx\lt0</script> if incorrectly. Then we formulate following loss functions:</p>
<ol>
<li>0/1 loss: <script type="math/tex">\min_\theta\sum_i L_{0/1}(\theta^Tx)</script>. We define <script type="math/tex">L_{0/1}(\theta^Tx) =1</script> if <script type="math/tex">y\cdot f \lt 0</script>, and <script type="math/tex">=0</script> o.w. Non convex and very hard to optimize.</li>
<li>Hinge loss: approximate 0/1 loss by <script type="math/tex">\min_\theta\sum_i H(\theta^Tx)</script>. We define <script type="math/tex">H(\theta^Tx) = max(0, 1 - y\cdot f)</script>. Apparently <script type="math/tex">H</script> is small if we classify correctly.</li>
<li>Logistic loss: <script type="math/tex">\min_\theta \sum_i log(1+\exp(-y\cdot \theta^Tx))</script>. Refer to my logistic regression notes for details.</li>
</ol>
<p>For regression:</p>
<ol>
<li>Square loss: <script type="math/tex">\min_\theta \sum_i||y^{(i)}-\theta^Tx^{(i)}||^2</script></li>
</ol>
<p>Fortunately, hinge loss, logistic loss and square loss are all convex functions. Convexity ensures global minimum and it’s computationally appleaing.<br>参考：<a href="http://www.cs.cmu.edu/~yandongl/loss.html" target="_blank" rel="external">http://www.cs.cmu.edu/~yandongl/loss.html</a><br>继续来看这些函数直观的意义，均匀取-2到2之间的点作为误差值，针对不同的损失函数，采取不同的处理方式，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">x=np.linspace(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">300</span>)<span class="comment">#均匀间隔</span></div><div class="line"><span class="comment">#Hinge loss</span></div><div class="line">hinge_loss_function = [] </div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>-x):  </div><div class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span>:  </div><div class="line">        hinge_loss_function.append(i)  </div><div class="line">    <span class="keyword">else</span>:  </div><div class="line">        hinge_loss_function.append(<span class="number">0</span>) </div><div class="line"><span class="comment">#指数损失</span></div><div class="line">exponential_loss_function = np.exp(-x)</div><div class="line"><span class="comment">#对数损失</span></div><div class="line">logistic_loss_function = np.log(<span class="number">1</span>+np.exp(-x))/np.log(<span class="number">2</span>) </div><div class="line"><span class="comment">#0/1损失</span></div><div class="line">l0_1_loss_function = []  </div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> x:  </div><div class="line">    <span class="keyword">if</span> j &lt; <span class="number">0</span>:  </div><div class="line">        l0_1_loss_function.append(<span class="number">1</span>)  </div><div class="line">    <span class="keyword">else</span>:  </div><div class="line">        l0_1_loss_function.append(<span class="number">0</span>) </div><div class="line"><span class="comment">#平方损失</span></div><div class="line">pingfang_loss_function = (x<span class="number">-1</span>) ** <span class="number">2</span> </div><div class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>))</div><div class="line">plt.plot(x, hinge_loss_function, <span class="string">'r-'</span>)  </div><div class="line"><span class="comment">#plt.plot(x, exponential_loss_function, 'b-')  </span></div><div class="line">plt.plot(x, logistic_loss_function, <span class="string">'g-'</span>)  </div><div class="line">plt.plot(x, l0_1_loss_function, <span class="string">'k-'</span>)  </div><div class="line">plt.plot(x, pingfang_loss_function, <span class="string">'c-'</span>)  </div><div class="line">plt.legend([<span class="string">'hinge_loss_function'</span>, <span class="string">'logistic_loss_function'</span>, <span class="string">'l0_1_loss_function'</span>, <span class="string">'pingfang_loss_function'</span>])  </div><div class="line">plt.ylim(<span class="number">0</span>,<span class="number">4</span>)</div></pre></td></tr></table></figure></p>
<p>如下图：<br><img src="/upload/essayimage/dl/dl0201.png" alt="dl0201"></p>
<p>上面这个图需要明白一点，x轴代表的是上面提到的<script type="math/tex">y\cdot f</script>，我们希望达到的目标是该值越大(正值)越好，也就是越远离0，这样我们的模型f就越好，因为这样拟合会很好(可以这样理解：对于坐标上的两种类型的点，我们找到一条直线将其分隔开，这条直线应该是离各类型的点最远的线，虽然靠近某一类型的点来划分也可以，但是这样预测能力就会降低)<br>其中可以看到0/1损失函数是最理想的，只要误差小于0，结果就是1；hinge损失函数是当误差小于1结果才为0，也就是说要求<script type="math/tex">y\cdot f >1</script>就好；而log损失函数就是要求<script type="math/tex">y\cdot f</script>越大越好；其中平方损失函数这个是不适合分类的，如果用分类的化，必须取<script type="math/tex">y\cdot f <0</script>的结果来作为损失函数（感知机就是这样）。<br>关于使用方面：二分类问题一般使用log损失或者是Hinge损失函数，回归问题一般使用平方损失函数。</p>
<h4 id="2-4-Gradient-Descent"><a href="#2-4-Gradient-Descent" class="headerlink" title="2.4 Gradient Descent"></a>2.4 Gradient Descent</h4><p>关于梯度下降，这里放一张图<br><img src="/upload/essayimage/dl/dl0202.png" alt="dl0202"><br>如上图，就以<script type="math/tex">J(w)=wx_{i}^2</script>为例，我们现在要找到使J最小的w，对于给定的<script type="math/tex">w_{0}</script>，我们需要找到最小的J，变量的更新应该是沿着梯度方向，更新w：<script type="math/tex">w=w_{0}-\frac{dJ(w)}{dw}</script><br>如果<script type="math/tex">w_{0}</script>在左边，就增加w；如果<script type="math/tex">w_{0}</script>在右边，就减小w</p>
<h4 id="2-10-Logistic-regression-on-m-examples"><a href="#2-10-Logistic-regression-on-m-examples" class="headerlink" title="2.10 Logistic regression on m examples"></a>2.10 Logistic regression on m examples</h4><p>这里将2.9节讲到的logistic回归中的梯度下降和对m个样例的梯度下降结合起来，并用python实现最原始的代码<br><img src="/upload/essayimage/dl/dl0203.png" alt="dl0203"><br>上图其实在讲反向传播算法，而且讲到了反向传播算法中的最原始的计算方式<br>这里对其中的每一个变量求导（遵循视频中的讲解，使用da代表损失函数对a的求导）：</p>
<script type="math/tex; mode=display">
da=\frac{dL(a,y)}{da}=-\frac{y}{a}+\frac{1-y}{1-a}\\
dz=\frac{dL(a,y)}{dz}=\frac{dL(a,y)}{da}\cdot \frac{da}{dz}=(-\frac{y}{a}+\frac{1-y}{1-a})\cdot a(1-a)=a-y\\
dw_{1}=\frac{dL(a,y)}{dw_{1}}=\frac{dL(a,y)}{da}\cdot \frac{da}{dz}\cdot \frac{dz}{dw_{1}}=(a-y)x_{1}\\
dw_{2}=\frac{dL(a,y)}{dw_{2}}=\frac{dL(a,y)}{da}\cdot \frac{da}{dz}\cdot \frac{dz}{dw_{2}}=(a-y)x_{2}\\
db=\frac{dL(a,y)}{db}=\frac{dL(a,y)}{da}.\frac{da}{dz}\cdot \frac{dz}{b}=a-y</script><p>其中对于Sigmoid的求导公式<script type="math/tex">f'(x)=f(x)(1-f(x))</script><br>更新<script type="math/tex">w_{1},w_{2},b</script>：</p>
<script type="math/tex; mode=display">
w_{1}=w_{1}-\alpha \cdot dw_{1}\\
w_{2}=w_{2}-\alpha \cdot dw_{2}\\
b=b-\alpha \cdot db</script><p>上面是对单个样本的梯度更新，下面logistic回归在多个样本上的python代码实现【理解此部分代码对于理解这两节讲的内容我觉得很重要，该代码为自己编写，可能存在错误】<br><img src="/upload/essayimage/dl/dl0204.png" alt="dl0204"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line">这里以[w1,w2],b为例</div><div class="line">其中sample为m行3列矩阵，第一列为x1的值，第二列为x2的值，第3列为y值</div><div class="line">传入的参数：</div><div class="line">sample为样本</div><div class="line">m为样本个数</div><div class="line">k为迭代次数</div><div class="line">alpha为学习率</div><div class="line">min_value为成本函数收敛最小界</div><div class="line">"""</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_regression_m</span><span class="params">(sample,m,k,alpha,min_value)</span>:</span></div><div class="line">    w1,w2,b,dw1,dw2,db=<span class="number">0</span><span class="comment">#初始化</span></div><div class="line">    <span class="comment">#迭代k次</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> k:</div><div class="line">        fun_j = <span class="number">0</span><span class="comment">#每次将成本函数归零</span></div><div class="line">        <span class="comment">#遍历m个样本</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> m:</div><div class="line">            z = w1 * sample[i][<span class="number">0</span>] + w2 * sample[i][<span class="number">1</span>] + b</div><div class="line">            a = <span class="number">1</span> / (<span class="number">1</span> + math.exp(-z))<span class="comment">#预测函数（模型）</span></div><div class="line">            fun_j += -(sample[i][<span class="number">2</span>] * math.log(a) + (<span class="number">1</span> - sample[i][<span class="number">2</span>]) * math.log(<span class="number">1</span> - a))<span class="comment">#成本函数</span></div><div class="line">            <span class="comment">#此部分参考上面讲解的链式求导</span></div><div class="line">            dz = a - sample[i][<span class="number">2</span>]<span class="comment">#单个样本的梯度值，中间量</span></div><div class="line">            dw1 += sample[i][<span class="number">0</span>] * dz<span class="comment">#将多个样本的梯度值相加</span></div><div class="line">            dw2 += sample[i][<span class="number">1</span>] * dz</div><div class="line">            db += dz</div><div class="line">        fun_j /= m</div><div class="line">        <span class="keyword">if</span> abs(fun_j)&lt;min_value:<span class="keyword">break</span><span class="comment">#计算代价函数的意义仅在于此</span></div><div class="line">        dw1 /= m</div><div class="line">        dw2 /= m</div><div class="line">        <span class="comment">#权重更新</span></div><div class="line">        w1-=alpha*dw1</div><div class="line">        w2-=alpha*dw2</div><div class="line">        b-=alpha*db</div></pre></td></tr></table></figure></p>
<h4 id="2-11-Vectorization"><a href="#2-11-Vectorization" class="headerlink" title="2.11 Vectorization"></a>2.11 Vectorization</h4><p>这节讲要避免使用for，而使用向量，这里举了一个例子，是使用np.dot来计算向量和for运算时间的对比：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="comment">#a=np.array([1,2,3,4])</span></div><div class="line">a=np.random.rand(<span class="number">1000000</span>)</div><div class="line">b=np.random.rand(<span class="number">1000000</span>)</div><div class="line">tic=time.time()</div><div class="line">c=np.dot(a,b)</div><div class="line">toc=time.time()</div><div class="line">print(<span class="string">"Vectorized version:"</span>+str(<span class="number">1000</span>*(toc-tic))+<span class="string">"ms"</span>)</div><div class="line"></div><div class="line">c=<span class="number">0</span></div><div class="line">tic=time.time()</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</div><div class="line">    c+=a[i]*b[i]</div><div class="line">toc=time.time()</div><div class="line">print(<span class="string">"for version:"</span>+str(<span class="number">1000</span>*(toc-tic))+<span class="string">"ms"</span>)</div></pre></td></tr></table></figure></p>
<p>Vectorized version:1.27410888671875ms<br>for version:702.2850513458252ms</p>
<h4 id="2-12-More-vectorization-examples"><a href="#2-12-More-vectorization-examples" class="headerlink" title="2.12 More vectorization examples"></a>2.12 More vectorization examples</h4><p>这一节讲到之前的logistic回归的代码可以使用向量优化，做一下修改，简化了一重循环，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_regression_m_2</span><span class="params">(sample,m,k,alpha,min_value)</span>:</span></div><div class="line">    <span class="comment"># 初始化</span></div><div class="line">    b,db=<span class="number">0</span></div><div class="line">    dw=np.zeros((sample.shape[<span class="number">1</span>],<span class="number">1</span>))<span class="comment">#表示的是创建一个行为sample.shape[1]，列为1的向量</span></div><div class="line">    w=np.zeros((sample.shape[<span class="number">1</span>],<span class="number">1</span>))</div><div class="line">    <span class="comment">#迭代k次</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> k:</div><div class="line">        fun_j = <span class="number">0</span><span class="comment">#每次将成本函数归零</span></div><div class="line">        <span class="comment">#遍历m个样本</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> m:</div><div class="line">            z = np.dot(sample[i][:<span class="number">2</span>],w) + b<span class="comment">#sample[i]为行向量，w为列向量</span></div><div class="line">            a = <span class="number">1</span> / (<span class="number">1</span> + math.exp(-z))<span class="comment">#预测函数（模型）</span></div><div class="line">            fun_j += -(sample[i][<span class="number">2</span>] * math.log(a) + (<span class="number">1</span> - sample[i][<span class="number">2</span>]) * math.log(<span class="number">1</span> - a))<span class="comment">#成本函数</span></div><div class="line">            <span class="comment">#此部分参考上面讲解的链式求导</span></div><div class="line">            dz = a - sample[i][<span class="number">2</span>]<span class="comment">#单个样本的梯度值，中间量</span></div><div class="line">            <span class="comment">#将多个样本的梯度值相加</span></div><div class="line">            dw+=sample[i]*dz</div><div class="line">            db += dz</div><div class="line">        fun_j /= m</div><div class="line">        <span class="keyword">if</span> abs(fun_j)&lt;min_value:<span class="keyword">break</span><span class="comment">#计算代价函数的意义仅在于此</span></div><div class="line">        dw/= m</div><div class="line">        <span class="comment">#权重更新</span></div><div class="line">        w-=alpha*dw</div><div class="line">        b-=alpha*db</div></pre></td></tr></table></figure></p>
<h4 id="2-14-Vectorizing-Logistic-Regression’s-Gradient-Computation"><a href="#2-14-Vectorizing-Logistic-Regression’s-Gradient-Computation" class="headerlink" title="2.14 Vectorizing Logistic Regression’s Gradient Computation"></a>2.14 Vectorizing Logistic Regression’s Gradient Computation</h4><p>这两节在讲简化上面的代码，如下图所示：<br><img src="/upload/essayimage/dl/dl0205.png" alt="dl0205"><br><img src="/upload/essayimage/dl/dl0206.png" alt="dl0206"><br>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line">继续修改该代码</div><div class="line">这里修改一下参数，sample表示的是x变量，y来表示真实值</div><div class="line">设x的特征为n,那么这里的sample表示的是n行m列的矩阵，即每一列代表一个x样本</div><div class="line">y为1行n列的向量</div><div class="line">"""</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_regression_m_3</span><span class="params">(sample,y,k,alpha,min_value)</span>:</span></div><div class="line">    m=sample.shape[<span class="number">1</span>]</div><div class="line">    <span class="comment"># 初始化</span></div><div class="line">    b=np.zeros((m,<span class="number">1</span>))</div><div class="line">    dw=np.zeros((sample.shape[<span class="number">0</span>],<span class="number">1</span>))<span class="comment">#表示的是创建一个行为sample.shape[1]，列为1的向量</span></div><div class="line">    w=np.zeros((sample.shape[<span class="number">0</span>],<span class="number">1</span>))</div><div class="line">    <span class="comment">#迭代k次</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> k:</div><div class="line">        z=np.dot(np.transpose(w),sample)+b</div><div class="line">        a=<span class="number">1</span>/(<span class="number">1</span> + math.exp(-z))</div><div class="line">        fun_j =<span class="number">-1</span>/m*(y*np.log(a)+(<span class="number">1</span>-y)*np.log(np.ones((<span class="number">1</span>,m))-a))</div><div class="line">        <span class="keyword">if</span> abs(fun_j) &lt; min_value: <span class="keyword">break</span>  <span class="comment"># 计算代价函数的意义仅在于此</span></div><div class="line">        dz=a-y</div><div class="line">        dw=<span class="number">1</span>/m*np.dot(sample,np.transpose(dz))</div><div class="line">        db=<span class="number">1</span>/m*np.sum(dz)</div><div class="line">        w=w-alpha*dw</div><div class="line">        b=b-alpha*db</div></pre></td></tr></table></figure></p>
<h4 id="Broadcasting-in-Python"><a href="#Broadcasting-in-Python" class="headerlink" title="Broadcasting in Python"></a>Broadcasting in Python</h4><p>如下图，对于向量和数值（scaler）运算，scaler会自动补齐对应的行/列；同样的道理，矩阵和向量的运行，向量也会相应的补齐对应的行/列<br><img src="/upload/essayimage/dl/dl0207.png" alt="dl0207"></p>
<h4 id="大作业"><a href="#大作业" class="headerlink" title="大作业"></a>大作业</h4><p>这个作业基本上前面基本上已经实践过了，作业地址：<a href="https://hub.coursera-notebooks.org/user/yfvzoyeraolmacyhglfoec/notebooks/Week%202/Logistic%20Regression%20as%20a%20Neural%20Network/Logistic%20Regression%20with%20a%20Neural%20Network%20mindset%20v4.ipynb" target="_blank" rel="external">Logistic Regression with a Neural Network mindset v4</a></p>
<h5 id="1-packgeds"><a href="#1-packgeds" class="headerlink" title="1 - packgeds"></a>1 - packgeds</h5><p>首先是导入数据，这句<code>from lr_utils import load_dataset</code>，我的jupter中没有lr_utils，就直接将lr_utils.py和对应的datasets集拷贝过来了<a href="https://github.com/andersy005/deep-learning-specialization-coursera/tree/master/01-Neural-Networks-and-Deep-Learning/week2" target="_blank" rel="external">github</a></p>
<h5 id="2-Overview-of-the-Problem-set"><a href="#2-Overview-of-the-Problem-set" class="headerlink" title="2 - Overview of the Problem set"></a>2 - Overview of the Problem set</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Loading the data (cat/non-cat)</span></div><div class="line">train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset()</div></pre></td></tr></table></figure>
<p>Exercise: Reshape the training and test data sets so that images of size (num_px, num_px, 3) are flattened into single vectors of shape (num_px  ∗∗  num_px  ∗∗  3, 1).<br>A trick when you want to flatten a matrix X of shape (a,b,c,d) to a matrix X_flatten of shape (b ∗∗ c ∗∗ d, a) is to use:<br>X_flatten = X.reshape(X.shape[0], -1).T      # X.T is the transpose of X<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Reshape the training and test examples</span></div><div class="line"></div><div class="line"><span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></div><div class="line">train_set_x_flatten = train_set_x_orig.reshape(train_set_x_orig.shape[<span class="number">0</span>],<span class="number">-1</span>).T</div><div class="line">test_set_x_flatten = test_set_x_orig.reshape(test_set_x_orig.shape[<span class="number">0</span>],<span class="number">-1</span>).T</div><div class="line"><span class="comment">### END CODE HERE ###</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> (<span class="string">"train_set_x_flatten shape: "</span> + str(train_set_x_flatten.shape))</div><div class="line"><span class="keyword">print</span> (<span class="string">"train_set_y shape: "</span> + str(train_set_y.shape))</div><div class="line"><span class="keyword">print</span> (<span class="string">"test_set_x_flatten shape: "</span> + str(test_set_x_flatten.shape))</div><div class="line"><span class="keyword">print</span> (<span class="string">"test_set_y shape: "</span> + str(test_set_y.shape))</div><div class="line"><span class="keyword">print</span> (<span class="string">"sanity check after reshaping: "</span> + str(train_set_x_flatten[<span class="number">0</span>:<span class="number">5</span>,<span class="number">0</span>]))</div></pre></td></tr></table></figure></p>
<p>train_set_x_flatten shape: (12288, 209)<br>train_set_y shape: (1, 209)<br>test_set_x_flatten shape: (12288, 50)<br>test_set_y shape: (1, 50)<br>sanity check after reshaping: [17 31 56 22 33]</p>
<p>One common preprocessing step in machine learning is to center and standardize your dataset, meaning that you substract the mean of the whole numpy array from each example, and then divide each example by the standard deviation of the whole numpy array. But for picture datasets, it is simpler and more convenient and works almost as well to just divide every row of the dataset by 255 (the maximum value of a pixel channel).<br>Let’s standardize our dataset.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Let's standardize our dataset.</span></div><div class="line">train_set_x = train_set_x_flatten/<span class="number">255.</span></div><div class="line">test_set_x = test_set_x_flatten/<span class="number">255.</span></div></pre></td></tr></table></figure></p>
<h5 id="4-General-Architecture-of-the-learning-algorithm"><a href="#4-General-Architecture-of-the-learning-algorithm" class="headerlink" title="4 - General Architecture of the learning algorithm"></a>4 - General Architecture of the learning algorithm</h5><p>省略了3<br>Exercise: Using your code from “Python Basics”, implement sigmoid(). As you’ve seen in the figure above, you need to compute  <script type="math/tex">sigmoid(w^Tx+b)=\frac{1}{1+e^{−(w^Tx+b)}}</script>to make predictions. Use np.exp()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Compute the sigmoid of z</div><div class="line">    Arguments:</div><div class="line">    z -- A scalar or numpy array of any size.</div><div class="line">    Return:</div><div class="line">    s -- sigmoid(z)</div><div class="line">    """</div><div class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></div><div class="line">    s = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-z))</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> s</div></pre></td></tr></table></figure></p>
<p>Initializing parameters<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_with_zeros</span><span class="params">(dim)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    This function creates a vector of zeros of shape (dim, 1) for w and initializes b to 0.</div><div class="line">    </div><div class="line">    Argument:</div><div class="line">    dim -- size of the w vector we want (or number of parameters in this case)</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    w -- initialized vector of shape (dim, 1)</div><div class="line">    b -- initialized scalar (corresponds to the bias)</div><div class="line">    """</div><div class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></div><div class="line">    w = np.zeros((dim,<span class="number">1</span>))</div><div class="line">    b = <span class="number">0</span></div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    <span class="keyword">assert</span>(w.shape == (dim, <span class="number">1</span>))</div><div class="line">    <span class="keyword">assert</span>(isinstance(b, float) <span class="keyword">or</span> isinstance(b, int))</div><div class="line">    <span class="keyword">return</span> w, b</div></pre></td></tr></table></figure></p>
<p>Forward and Backward propagation<br>Exercise: Implement a function propagate() that computes the cost function and its gradient.<br>Hints:<br>Forward Propagation:</p>
<ul>
<li><p>You get X</p>
</li>
<li><p>You compute </p>
<script type="math/tex; mode=display">
A=σ(w^TX+b)=(a^{(0)},a^{(1)},...,a^{(m−1)},a^{(m)})</script></li>
<li><p>You calculate the cost function: </p>
<script type="math/tex; mode=display">
 J=−\frac{1}{m}∑_{i=1}^my^{(i)}log(a^{(i)})+(1−y^{(i)})log(1−a^{(i)})</script></li>
</ul>
<p>Here are the two formulas you will be using:</p>
<script type="math/tex; mode=display">
\frac{∂J}{∂w}=\frac{1}{m}X(A−Y)^T\\
\frac{∂J}{∂b}=\frac{1}{m}∑_{i=1}^m(a^{(i)}−y^{(i)})</script><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">propagate</span><span class="params">(w, b, X, Y)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Implement the cost function and its gradient for the propagation explained above</div><div class="line"></div><div class="line">    Arguments:</div><div class="line">    w -- weights, a numpy array of size (num_px * num_px * 3, 1)</div><div class="line">    b -- bias, a scalar</div><div class="line">    X -- data of size (num_px * num_px * 3, number of examples)</div><div class="line">    Y -- true "label" vector (containing 0 if non-cat, 1 if cat) of size (1, number of examples)</div><div class="line"></div><div class="line">    Return:</div><div class="line">    cost -- negative log-likelihood cost for logistic regression</div><div class="line">    dw -- gradient of the loss with respect to w, thus same shape as w</div><div class="line">    db -- gradient of the loss with respect to b, thus same shape as b</div><div class="line">    </div><div class="line">    Tips:</div><div class="line">    - Write your code step by step for the propagation. np.log(), np.dot()</div><div class="line">    """</div><div class="line">    </div><div class="line">    m = X.shape[<span class="number">1</span>]</div><div class="line">    </div><div class="line">    <span class="comment"># FORWARD PROPAGATION (FROM X TO COST)</span></div><div class="line">    <span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></div><div class="line">    A = sigmoid(np.dot(w.T,X)+b)               </div><div class="line">    cost = <span class="number">-1</span>/m*np.sum(Y*np.log(A)+(<span class="number">1</span>-Y)*np.log(<span class="number">1</span>-A))                                <span class="comment"># compute cost</span></div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># BACKWARD PROPAGATION (TO FIND GRAD)</span></div><div class="line">    <span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></div><div class="line">    dw = <span class="number">1</span>/m*np.dot(X,(A-Y).T)</div><div class="line">    db = <span class="number">1</span>/m*np.sum(A-Y)</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line"></div><div class="line">    <span class="keyword">assert</span>(dw.shape == w.shape)</div><div class="line">    <span class="keyword">assert</span>(db.dtype == float)</div><div class="line">    cost = np.squeeze(cost)</div><div class="line">    <span class="keyword">assert</span>(cost.shape == ())</div><div class="line">    </div><div class="line">    grads = &#123;<span class="string">"dw"</span>: dw,</div><div class="line">             <span class="string">"db"</span>: db&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> grads, cost</div></pre></td></tr></table></figure>
<p>Exercise: Write down the optimization function. The goal is to learn  ww  and  bb  by minimizing the cost function  J . For a parameter  θ, the update rule is  θ=θ−α dθ , where  α is the learning rate.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(w, b, X, Y, num_iterations, learning_rate, print_cost = False)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    This function optimizes w and b by running a gradient descent algorithm</div><div class="line">    </div><div class="line">    Arguments:</div><div class="line">    w -- weights, a numpy array of size (num_px * num_px * 3, 1)</div><div class="line">    b -- bias, a scalar</div><div class="line">    X -- data of shape (num_px * num_px * 3, number of examples)</div><div class="line">    Y -- true "label" vector (containing 0 if non-cat, 1 if cat), of shape (1, number of examples)</div><div class="line">    num_iterations -- number of iterations of the optimization loop</div><div class="line">    learning_rate -- learning rate of the gradient descent update rule</div><div class="line">    print_cost -- True to print the loss every 100 steps</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    params -- dictionary containing the weights w and bias b</div><div class="line">    grads -- dictionary containing the gradients of the weights and bias with respect to the cost function</div><div class="line">    costs -- list of all the costs computed during the optimization, this will be used to plot the learning curve.</div><div class="line">    </div><div class="line">    Tips:</div><div class="line">    You basically need to write down two steps and iterate through them:</div><div class="line">        1) Calculate the cost and the gradient for the current parameters. Use propagate().</div><div class="line">        2) Update the parameters using gradient descent rule for w and b.</div><div class="line">    """</div><div class="line">    </div><div class="line">    costs = []</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_iterations):</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment"># Cost and gradient calculation (≈ 1-4 lines of code)</span></div><div class="line">        <span class="comment">### START CODE HERE ### </span></div><div class="line">        grads, cost = propagate(w, b, X, Y)</div><div class="line">        <span class="comment">### END CODE HERE ###</span></div><div class="line">        </div><div class="line">        <span class="comment"># Retrieve derivatives from grads</span></div><div class="line">        dw = grads[<span class="string">"dw"</span>]</div><div class="line">        db = grads[<span class="string">"db"</span>]</div><div class="line">        </div><div class="line">        <span class="comment"># update rule (≈ 2 lines of code)</span></div><div class="line">        <span class="comment">### START CODE HERE ###</span></div><div class="line">        w = w-learning_rate*dw</div><div class="line">        b = b-learning_rate*db</div><div class="line">        <span class="comment">### END CODE HERE ###</span></div><div class="line">        </div><div class="line">        <span class="comment"># Record the costs</span></div><div class="line">        <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">            costs.append(cost)</div><div class="line">        </div><div class="line">        <span class="comment"># Print the cost every 100 training examples</span></div><div class="line">        <span class="keyword">if</span> print_cost <span class="keyword">and</span> i % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">            <span class="keyword">print</span> (<span class="string">"Cost after iteration %i: %f"</span> %(i, cost))</div><div class="line">    </div><div class="line">    params = &#123;<span class="string">"w"</span>: w,</div><div class="line">              <span class="string">"b"</span>: b&#125;</div><div class="line">    </div><div class="line">    grads = &#123;<span class="string">"dw"</span>: dw,</div><div class="line">             <span class="string">"db"</span>: db&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> params, grads, costs</div></pre></td></tr></table></figure></p>
<p>Exercise: The previous function will output the learned w and b. We are able to use w and b to predict the labels for a dataset X. Implement the predict() function. There is two steps to computing predictions:</p>
<ol>
<li>Calculate  <script type="math/tex">Ŷ =A=σ(w^TX+b)</script></li>
<li>Convert the entries of a into 0 (if activation &lt;= 0.5) or 1 (if activation &gt; 0.5), stores the predictions in a vector Y_prediction. If you wish, you can use an if/else statement in a for loop (though there is also a way to vectorize this).<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(w, b, X)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Predict whether the label is 0 or 1 using learned logistic regression parameters (w, b)</div><div class="line">    </div><div class="line">    Arguments:</div><div class="line">    w -- weights, a numpy array of size (num_px * num_px * 3, 1)</div><div class="line">    b -- bias, a scalar</div><div class="line">    X -- data of size (num_px * num_px * 3, number of examples)</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    Y_prediction -- a numpy array (vector) containing all predictions (0/1) for the examples in X</div><div class="line">    '''</div><div class="line">    </div><div class="line">    m = X.shape[<span class="number">1</span>]</div><div class="line">    Y_prediction = np.zeros((<span class="number">1</span>,m))</div><div class="line">    w = w.reshape(X.shape[<span class="number">0</span>], <span class="number">1</span>)</div><div class="line">    </div><div class="line">    <span class="comment"># Compute vector "A" predicting the probabilities of a cat being present in the picture</span></div><div class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></div><div class="line">    A = sigmoid(np.dot(w.T,X)+b) </div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(A.shape[<span class="number">1</span>]):</div><div class="line">        </div><div class="line">        <span class="comment"># Convert probabilities A[0,i] to actual predictions p[0,i]</span></div><div class="line">        <span class="comment">### START CODE HERE ### (≈ 4 lines of code)</span></div><div class="line">        <span class="keyword">if</span> A[<span class="number">0</span>][i]&gt;<span class="number">0.5</span>:Y_prediction[<span class="number">0</span>][i]=<span class="number">1</span></div><div class="line">        <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="keyword">assert</span>(Y_prediction.shape == (<span class="number">1</span>, m))</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">return</span> Y_prediction</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="5-Merge-all-functions-into-a-model"><a href="#5-Merge-all-functions-into-a-model" class="headerlink" title="5 -Merge all functions into a model"></a>5 -Merge all functions into a model</h5><p>You will now see how the overall model is structured by putting together all the building blocks (functions implemented in the previous parts) together, in the right order.<br>Exercise: Implement the model function. Use the following notation:</p>
<ul>
<li>Y_prediction for your predictions on the test set</li>
<li>Y_prediction_train for your predictions on the train set</li>
<li>w, costs, grads for the outputs of optimize()</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(X_train, Y_train, X_test, Y_test, num_iterations = <span class="number">2000</span>, learning_rate = <span class="number">0.5</span>, print_cost = False)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Builds the logistic regression model by calling the function you've implemented previously</div><div class="line">    </div><div class="line">    Arguments:</div><div class="line">    X_train -- training set represented by a numpy array of shape (num_px * num_px * 3, m_train)</div><div class="line">    Y_train -- training labels represented by a numpy array (vector) of shape (1, m_train)</div><div class="line">    X_test -- test set represented by a numpy array of shape (num_px * num_px * 3, m_test)</div><div class="line">    Y_test -- test labels represented by a numpy array (vector) of shape (1, m_test)</div><div class="line">    num_iterations -- hyperparameter representing the number of iterations to optimize the parameters</div><div class="line">    learning_rate -- hyperparameter representing the learning rate used in the update rule of optimize()</div><div class="line">    print_cost -- Set to true to print the cost every 100 iterations</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">    d -- dictionary containing information about the model.</div><div class="line">    """</div><div class="line">    </div><div class="line">    <span class="comment">### START CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># initialize parameters with zeros (≈ 1 line of code)</span></div><div class="line">    w, b = initialize_with_zeros(X_train.shape[<span class="number">0</span>])</div><div class="line"></div><div class="line">    <span class="comment"># Gradient descent (≈ 1 line of code)</span></div><div class="line">    parameters, grads, costs = optimize(w, b, X_train, Y_train, num_iterations, learning_rate)</div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve parameters w and b from dictionary "parameters"</span></div><div class="line">    w = parameters[<span class="string">"w"</span>]</div><div class="line">    b = parameters[<span class="string">"b"</span>]</div><div class="line">    </div><div class="line">    <span class="comment"># Predict test/train set examples (≈ 2 lines of code)</span></div><div class="line">    Y_prediction_test = predict(w, b, X_test)</div><div class="line">    Y_prediction_train = predict(w, b, X_train)</div><div class="line"></div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line"></div><div class="line">    <span class="comment"># Print train/test Errors</span></div><div class="line">    print(<span class="string">"train accuracy: &#123;&#125; %"</span>.format(<span class="number">100</span> - np.mean(np.abs(Y_prediction_train - Y_train)) * <span class="number">100</span>))</div><div class="line">    print(<span class="string">"test accuracy: &#123;&#125; %"</span>.format(<span class="number">100</span> - np.mean(np.abs(Y_prediction_test - Y_test)) * <span class="number">100</span>))</div><div class="line"></div><div class="line">    </div><div class="line">    d = &#123;<span class="string">"costs"</span>: costs,</div><div class="line">         <span class="string">"Y_prediction_test"</span>: Y_prediction_test, </div><div class="line">         <span class="string">"Y_prediction_train"</span> : Y_prediction_train, </div><div class="line">         <span class="string">"w"</span> : w, </div><div class="line">         <span class="string">"b"</span> : b,</div><div class="line">         <span class="string">"learning_rate"</span> : learning_rate,</div><div class="line">         <span class="string">"num_iterations"</span>: num_iterations&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> d</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = <span class="number">2000</span>, learning_rate = <span class="number">0.005</span>, print_cost = <span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>train accuracy: 99.04306220095694 %<br>test accuracy: 70.0 %<br>到此就结束了，当然我们用训练集拟合，再对训练集预测，准确度肯定接近于1了，而测试集上只有70，说明过拟合了(我们的目的是让训练集和测试集结果尽量相同)<br>我这里按照教程将迭代次数改为5000后的结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">learning_rates = [<span class="number">0.01</span>, <span class="number">0.001</span>, <span class="number">0.0001</span>]</div><div class="line">models = &#123;&#125;</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> learning_rates:</div><div class="line">    <span class="keyword">print</span> (<span class="string">"learning rate is: "</span> + str(i))</div><div class="line">    models[str(i)] = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = <span class="number">5000</span>, learning_rate = i, print_cost = <span class="keyword">False</span>)</div><div class="line">    <span class="keyword">print</span> (<span class="string">'\n'</span> + <span class="string">"-------------------------------------------------------"</span> + <span class="string">'\n'</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> learning_rates:</div><div class="line">    plt.plot(np.squeeze(models[str(i)][<span class="string">"costs"</span>]), label= str(models[str(i)][<span class="string">"learning_rate"</span>]))</div><div class="line"></div><div class="line">plt.ylabel(<span class="string">'cost'</span>)</div><div class="line">plt.xlabel(<span class="string">'iterations'</span>)</div><div class="line"></div><div class="line">legend = plt.legend(loc=<span class="string">'upper center'</span>, shadow=<span class="keyword">True</span>)</div><div class="line">frame = legend.get_frame()</div><div class="line">frame.set_facecolor(<span class="string">'0.90'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure></p>
<hr>
<p>learning rate is: 0.01<br>train accuracy: 100.0<br>test accuracy: 68.0 </p>
<hr>
<p>learning rate is: 0.001<br>train accuracy: 96.65071770334929<br>test accuracy: 74.0 </p>
<hr>
<p>learning rate is: 0.0001<br>train accuracy: 77.51196172248804<br>test accuracy: 56.0 </p>
<hr>
<p><img src="/upload/essayimage/dl/dl0208.png" alt="dl0208"><br>这里可以看到如果学习率为0.001时，在测试集上的结果达到了74，这是因为由于学习率比较小，也就是沿梯度下降慢(从图中也可以很明显的发现),训练集并没有完全收敛，那么就谈不上过拟合，也就是说如果迭代次数继续加大，在0.001上仍然可以找到更好的结果，同理对0.1而言，减小迭代次数也可以发现更好的结果；不过这些后没有必要，使用正则化或者其他可以解决过拟合问题<br>完！</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>如果觉得有帮助，给我打赏吧！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/upload/image/wechat.png" alt="Peng song WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/upload/image/alipay.png" alt="Peng song Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/06/leetcode135/" rel="next" title="135. Candy">
                <i class="fa fa-chevron-left"></i> 135. Candy
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/07/leetcode136/" rel="prev" title="136. Single Number">
                136. Single Number <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yODMzMy80OTA1"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/upload/image/head.png"
               alt="Peng song" />
          <p class="site-author-name" itemprop="name">Peng song</p>
           
              <p class="site-description motion-element" itemprop="description">海阔凭鱼跃，天高任鸟飞</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">122</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/moluchase" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/molu_chase/article/" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-csdn"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-logistic-Regression-Cost-Function"><span class="nav-number">1.</span> <span class="nav-text">2.3 logistic Regression: Cost Function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-Gradient-Descent"><span class="nav-number">2.</span> <span class="nav-text">2.4 Gradient Descent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-10-Logistic-regression-on-m-examples"><span class="nav-number">3.</span> <span class="nav-text">2.10 Logistic regression on m examples</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-11-Vectorization"><span class="nav-number">4.</span> <span class="nav-text">2.11 Vectorization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-12-More-vectorization-examples"><span class="nav-number">5.</span> <span class="nav-text">2.12 More vectorization examples</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-14-Vectorizing-Logistic-Regression’s-Gradient-Computation"><span class="nav-number">6.</span> <span class="nav-text">2.14 Vectorizing Logistic Regression’s Gradient Computation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Broadcasting-in-Python"><span class="nav-number">7.</span> <span class="nav-text">Broadcasting in Python</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#大作业"><span class="nav-number">8.</span> <span class="nav-text">大作业</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-packgeds"><span class="nav-number">8.1.</span> <span class="nav-text">1 - packgeds</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Overview-of-the-Problem-set"><span class="nav-number">8.2.</span> <span class="nav-text">2 - Overview of the Problem set</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-General-Architecture-of-the-learning-algorithm"><span class="nav-number">8.3.</span> <span class="nav-text">4 - General Architecture of the learning algorithm</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Merge-all-functions-into-a-model"><span class="nav-number">8.4.</span> <span class="nav-text">5 -Merge all functions into a model</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017/04 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Peng song</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("i4ELzHGwKH3mMkXr4eMOdJjm-gzGzoHsz", "Mz3PflHjlldl1BtsxPz9VuhR");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  

  

  

  

</body>
</html>
